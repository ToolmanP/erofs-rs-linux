// Copyright 2024 Yiyang Wu
// SPDX-License-Identifier: MIT or GPL-2.0-or-later

//! EROFS Rust Kernel Module Helpers Implementation
//! This is only for experimental purpose. Feedback is always welcome.

#[allow(dead_code)]
#[allow(missing_docs)]
pub(crate) mod rust;
use core::ffi::*;
use core::ptr::NonNull;

use kernel::bindings::inode;
use kernel::container_of;

use rust::{erofs_sys::*, kinode::*, ksuperblock::*};

#[repr(C)]
struct ErofsBuf {
    mapping: NonNull<c_void>,
    page: NonNull<c_void>,
    base: NonNull<c_void>,
    kmap_type: c_int,
}

/// A helper sturct to map blocks for iomap_begin because iomap is not generated by bindgen
#[repr(C)]
pub struct ErofsMapBlocks {
    buf: ErofsBuf,
    pub(crate) m_pa: u64,
    pub(crate) m_la: u64,
    pub(crate) m_plen: u64,
    pub(crate) m_llen: u64,
    pub(crate) m_deviceid: u16,
    pub(crate) m_flags: u32,
}
/// Exported as a replacement for erofs_map_blocks.
#[no_mangle]
pub unsafe extern "C" fn erofs_map_blocks_rust(
    k_inode: NonNull<inode>,
    mut map: NonNull<ErofsMapBlocks>,
) -> c_int {
    // SAFETY: super_block and superblockinfo is always initialized in k_inode.
    let sbi = erofs_sbi(unsafe { NonNull::new(k_inode.as_ref().i_sb).unwrap() });
    // SAFETY: We are sure that the inode is a Kernel Inode since alloc_inode is called
    let erofs_inode = unsafe { &*container_of!(k_inode.as_ptr(), KernelInode, k_inode) };
    // SAFETY: The map is always initialized in the caller.
    match sbi
        .filesystem
        .map(erofs_inode, unsafe { map.as_ref().m_la } as Off)
    {
        Ok(m) => unsafe {
            map.as_mut().m_pa = m.physical.start;
            map.as_mut().m_la = map.as_ref().m_la;
            map.as_mut().m_plen = m.physical.len;
            map.as_mut().m_llen = m.physical.len;
            map.as_mut().m_deviceid = m.device_id;
            map.as_mut().m_flags = m.map_type.into();
            0
        },
        Err(e) => i32::from(e) as c_int,
    }
}
